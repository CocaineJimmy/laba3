//это библиотеки
#include <iostream>//библиотека с классами, функциями и переменными для возможности ввода-вывода на плюсах
#include <string> //с ней мы можем работать со строками
#include <stack> //дает нам возможность легче создавать стеки, где уже имеются нужные функции(для упрощения работы и уменьшения объема кода)
#include <Windows.h> //для команд SetConsoleCP(1251); SetConsoleOutputCP(1251); в начале main, чтобы в консоле нормально отображались русские символы
#include <conio.h> //для команды _getch() которая принимает какой-то один символ, который нажал user

using namespace std; //для того, чтобы каждый раз не писать std::
//конечно лучше не использовать using namespace в каких-то больших проектах, тк там будут использоваться не только пространства имен std и могут происходить ошибки тупо из-за компилятора
//но это лаба обычная, поэтому буква ю

struct Stack {//создаем структуру Stack, где мы пишем, что в ней будет переменная char(один какой-то символ) и указатель next на следующую структуру стэк
    //предназначена для записи знаков и дальнейших махинаций с ними
    char info;
    Stack* next;
};
//дальше идут функции
//для создания функции, сначала мы указываем, что именно мы будем возвращать(какой тип информации Stack, int, void и тд)
//потом придумываем имя этой функции и в скобках указываем, что именно будет принимать наша функция(какой тип информации и сколько)

Stack* del(Stack* p, char* out) {//функция удаления элемента в стеке
    Stack* t = p; //это
    (*out) = p->info;//это
    delete t;// и это махинации для освобождения памяти
    p = p->next;//а это само удаление
    return p;
}

Stack* add(Stack* p, char in) {//функция доваления элемента в стек
    Stack* t = new Stack; //создаем пустой стэк
    t->info = in; // туда запихиваем инфу
    t->next = p; // и прекрепляем наш старый стэк
    return t; // и возвращаем новый готовый стэк
}

int prioritet(char a) {//данная функция смотрит, какой знак мы сейчас рассматриваем и возврощает приоритет данного знака для дальнейшего представления формулы в дереве как в постфиксной, так и в инфиксной форме
    switch (a) {
    case '^': return 4;
    case '*': case '/': return 3;
    case '-': case '+': return 2;
    case '(': return 1;
    }
    return 0;
}

struct Node {//структура Node(которая и есть наше бинарное дерево),где мы пишем, что в ней будет переменная string(тип какая-та строка) и 2 указателя left, right(то есть указатели на левую и правую ветвь листа) 
    string data;
    Node* left;
    Node* right;
};

bool isOperator(string c) {//функция, которая проверяет, это вообще знак или нет
    if (c == "+" || c == "-" || c == "*" || c == "/") {
        return true;
    }
    return false;
}

void inorder(Node* t) {//рекурсивная функция(то есть вызывает саму себя), которая выводит формулу в определенной записи
    if (t) {//проверка, что дошли ли мы до конца или нет
        inorder(t->left);//запуск этой же функции уже начиная с левой ветки
        cout << t->data << " ";
        inorder(t->right);//запуск этой же функции уже начиная с правой ветки ветки
    }
}

Node* newNode(string v) {//функция создания бинарного дерева
    Node* temp = new Node; //создаем дерево
    temp->left = temp->right = NULL; //говорим, что ветви наши будут пустые(чтобы программа не закинула туда мусорные значения)
    temp->data = v;//запихиваем в наш корень информацию
    return temp;//возвращаем это дерево
};

Node* constructTree1(string postfix) {//функция построения нашего бинарного дерева
    stack<Node*> st; //создаем стэк благодаря библиотеки(сделал я это для удобства записи в дерево)

    for (int i = 0; i < postfix.length(); i++) {//дальше заходим в цикл, который пройдется по всей формуле и будет записывать все в наше дерево

        if (isOperator(string(1, postfix[i]))) {//если тот символ, который мы смотрим, все таки знак то  /string(1, postfix[i]) - это перевод из char(postfix[i]) в string
            //создание новых веток
            Node* node = newNode(string(1, postfix[i]));

            node->right = st.top();//st.top возвращает верхний элемент стэка
            st.pop();//st.pop удаляет верхнее значение

            node->left = st.top();
            st.pop();

            st.push(node);//st.push вставляет элемент в верх стэка
        }

        else {
            st.push(newNode(string(1, postfix[i])));
        }
    }

    return st.top();
}

string postfix(string infix) {//переводит формулу из инфиксной записи в постфиксную(алгоритм перевода в польскую запись по сути)
    /*алгоритм
    1. взять очередной элемент
    2. если это не знак операции, добавить его в стек
    3. если это знак операции то посмотреть приоритет и сравнить с др знаком в стеке, если все оке то
    4. взять из стека два операнда
    5. выполнить операцию и записать результат в стек
    6. перейти к шагу 1*/
    int len = infix.size(), k;
    char ss;
    Stack* begin = NULL;
    string OutStr;
    char a = ' ';
    int kol = 0;
    for (k = 0; k < len; k++) {
        ss = infix[k];
        if (ss == '(')
            begin = add(begin, ss);
        if (ss == ')') {

            while ((begin->info) != '(') {
                begin = del(begin, &a);
                OutStr += a;
            }
            begin = del(begin, &a);
        }

        if (ss >= 'a' && ss <= 'z') {
            kol++;
            OutStr += ss;
        }

        if (ss == '*' or ss == '/' or ss == '+' or ss == '-' or ss == '^') {
            while (begin != NULL && prioritet(begin->info) >= prioritet(ss)) {
                begin = del(begin, &a);

                OutStr += a;
            }
            begin = add(begin, ss);
        }
    }

    while (begin != NULL) {
        begin = del(begin, &a);
        OutStr += a;
    }

    return OutStr;
}

void see(Node* seeTree, int u) {// рекурсивная функция просмотра бинарного дерева(переменная u введена для того, чтобы можно было красиво представить бинарное дерево, те его ветви)
    if (!seeTree) {//если дерево не создано, то посылаем куда подальше

        return;
    }
    else {
        see(seeTree->left, ++u);//смотрит, что там в левой ветви
        //сам вывод в консоль
        for (int i = 0; i < u; ++i) cout << "|";
        cout << "->" << seeTree->data << endl;
        u--;
    }
    see(seeTree->right, ++u);//смотрит, что там в правой ветви
}

int main() {
    string formula;//создаем для того, чтобы можно было принимать инфу от user
    Node* r;//создаем наше бинарное дерево
    SetConsoleCP(1251);
    SetConsoleOutputCP(1251);
    while (1) {//бесконечный цикл
        cout << "Операции:" << endl;
        cout << "1. Ввести формулу в постфиксной записи и получить в инфиксной" << endl;
        cout << "2. Ввести формулу в инфиксной записи и получить в постфиксной" << endl;
        cout << "0. Завершить" << endl;
        switch (_getch())//принимает клавишу,которую нажал пользователь
        {
        case '1':
            system("cls");//очищает консоль
            cout << "Введите формулу в постфиксной записи и без пробелов(ab+ef*g*-)" << endl;
            cin >> formula;
            r = constructTree1(formula);//вызываем функцию построение дерева, которая вернет нам дерево что функция сделала и присвоит нашему дереву r 
            cout << "Бинарное дерево:" << endl;
            see(r, 0);//смотрим дерево
            cout << endl << "Инфиксная запись: ";
            inorder(r);//смотрим саму формулу в другой записи
            cout << endl;
            break;

        case '2':
            system("cls");
            cout << "Введите формулу в инфиксной записи и без пробелов(a+b-e*f*g)" << endl;
            cin>>formula;
            formula = postfix(formula);//перевод формулы в постфиксную
            r = constructTree1(formula);//вызываем функцию построение дерева, которая вернет нам дерево что функция сделала и присвоит нашему дереву r 
            cout << "Бинарное дерево:" << endl;
            see(r, 0);//смотрим дерево
            cout << endl << "Поствиксная запись: ";
            cout << formula << endl;//смотрим саму формулу в другой записи
            break;

        case '0':
            return 0;
            break;
        default://вызывается только если не сработал ни один case(те не нажата не одна из наших кнопок)
            system("cls");
            break;
        }

    }
}